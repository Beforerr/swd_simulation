[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site",
    "crumbs": [
      "Home",
      "About"
    ]
  },
  {
    "objectID": "warpx/oblique_linear_alfven/analysis.html",
    "href": "warpx/oblique_linear_alfven/analysis.html",
    "title": "Analysis",
    "section": "",
    "text": "import matplotlib.pyplot as plt\n\n\n# load simulation parameters\nimport json\n\nwith open(\"sim_parameters.json\", \"rb\") as f:\n    sim = json.load(f)\n\n\nsim\n\n{'dim': 2,\n 'diag': True,\n 'n0': 100000000.0,\n 'm_ion_norm': 100,\n 'm_ion': 9.1093837015e-29,\n 'v_ti': 207957.64245251397,\n 'nz': 32,\n 'nx': 1024,\n 'nppc': 64,\n 'diag_steps': 64,\n 'beta': 0.1,\n 'vA': 930014.8499288347,\n 'plasma_resistivity': 1e-07,\n 'T_plasma': 24.588292599321438,\n 'Te': 24.588292599321438,\n 't_ci': 0.035723867528782094,\n 'd_i': 5314.093261582036,\n 'time_norm': 100.0,\n 'dt_norm': 0.015625,\n 'diag_time_norm': 1,\n 'Lz_norm': 4,\n 'Lx_norm': 128,\n 'dz_norm': 0.125,\n 'test': True,\n 'B0': 1.0000000000000001e-07,\n 'vA_over_c': None,\n 'A': 0.1,\n 'w_ci': 175.88200107721636,\n 'w_pi': 56414.602311806266,\n 'dz': 664.2616576977545,\n 'Lz': 21256.373046328143,\n 'Lx': 680203.9374825006,\n 'k': 9.237208079733046e-06}\n\n\n\nsim[\"Lx\"]\n\n680203.9374825006\n\n\n\n\n\n\n\nimport yt\n\n\nts = yt.load('./diags/diag???????')\n# ts = yt.load('./diags/diag???0032')\n\n\ndef plot(ds, normalize = True):\n    ad = ds.all_data()\n\n    x = ad[\"x\"]\n    \n    if normalize:\n        x = x / sim['d_i']\n    \n    ax = plt.subplot()\n    for field in [\"Bx\", \"By\", \"Bz\"]:\n        ax.plot(x, ad[field], label=field)\n        \ndef hodogram(ds, comp1=\"By\", comp2=\"Bz\"):\n    time = ds.current_time\n    time_norm = time.value / sim['t_ci']\n    ad = ds.all_data()\n    plt.plot(ad[comp1], ad[comp2], label=f\"t={time_norm:.2f}\")\n    plt.xlabel(comp1)\n    plt.ylabel(comp2)\n\n\ni=2\n# for ds in ts[i:i+1]:\nfor ds in ts[0:i]:\n    plot(ds)\n\nyt : [INFO     ] 2024-03-14 10:08:01,766 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-14 10:08:01,767 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:01,768 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:01,769 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:08:01,840 Parameters: current_time              = 0.035723867528782094\nyt : [INFO     ] 2024-03-14 10:08:01,841 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:01,842 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:01,842 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\ni=3\n# for ds in ts[i:i+1]:\nfor ds in ts[0:i]:\n    plot(ds)\n\nyt : [INFO     ] 2024-03-14 10:08:02,391 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-14 10:08:02,392 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:02,392 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:02,393 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:08:02,460 Parameters: current_time              = 0.035723867528782094\nyt : [INFO     ] 2024-03-14 10:08:02,461 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:02,461 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:02,461 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:08:02,525 Parameters: current_time              = 0.07144773505756419\nyt : [INFO     ] 2024-03-14 10:08:02,525 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:02,526 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:02,526 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\ni=4\n# for ds in ts[i:i+1]:\nfor ds in ts[0:i]:\n    plot(ds)\n\nyt : [INFO     ] 2024-03-14 10:07:58,686 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-14 10:07:58,686 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,687 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,688 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:07:58,759 Parameters: current_time              = 0.035723867528782094\nyt : [INFO     ] 2024-03-14 10:07:58,760 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,760 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,761 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:07:58,913 Parameters: current_time              = 0.07144773505756419\nyt : [INFO     ] 2024-03-14 10:07:58,913 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,913 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,914 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: current_time              = 0.10717160258634628\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\ni = 2\nds = ts[i]\nad = ds.all_data()\nad[\"B_x\"]\n\nyt : [INFO     ] 2024-03-13 19:52:44,658 Parameters: current_time              = 0.014289547011512778\nyt : [INFO     ] 2024-03-13 19:52:44,659 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:44,659 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:44,660 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\nunyt_array([nan, nan, nan, ..., nan, nan, nan], 'T')\n\n\n\nfor ds in ts:\n    hodogram(ds)\n    plt.legend()\n\nyt : [INFO     ] 2024-03-13 19:52:39,551 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-13 19:52:39,552 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:39,552 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:39,553 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-13 19:52:39,722 Parameters: current_time              = 0.007144773505756403\nyt : [INFO     ] 2024-03-13 19:52:39,723 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:39,723 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:39,724 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-13 19:52:39,793 Parameters: current_time              = 0.014289547011512778\nyt : [INFO     ] 2024-03-13 19:52:39,794 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:39,794 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:39,795 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\nds.current_time\n\nunyt_quantity(1.31178042, 'code_time')\n\n\n\nds.field_list\n\n[('boxlib', 'Bx'),\n ('boxlib', 'By'),\n ('boxlib', 'Bz'),\n ('boxlib', 'Ex'),\n ('boxlib', 'Ey'),\n ('boxlib', 'Ez'),\n ('boxlib', 'jx'),\n ('boxlib', 'jy'),\n ('boxlib', 'jz')]\n\n\n\nyt.SlicePlot(ds, \"z\", (\"boxlib\", \"Bz\"))\n\nyt : [INFO     ] 2024-03-13 17:10:23,638 xlim = -728644.160452 728644.160452\nyt : [INFO     ] 2024-03-13 17:10:23,639 ylim = 0.000000 45540.260028\nyt : [INFO     ] 2024-03-13 17:10:23,640 xlim = -728644.160452 728644.160452\nyt : [INFO     ] 2024-03-13 17:10:23,641 ylim = 0.000000 45540.260028\nyt : [INFO     ] 2024-03-13 17:10:23,643 Making a fixed resolution buffer of (('boxlib', 'Bz')) 800 by 800\n\n\n\n\n\n\n\n\n\nimport openpmd_api as io\n\n# example: data handling\nimport numpy as np\n\n\nopenpmd_backend = \"h5\"\nseries = io.Series(f\"diags/diag1/openpmd_%06T.{openpmd_backend}\", io.Access.read_only)\n\nError: Read Error in frontend \nObject type:    File\nError type: Inaccessible\nFurther description:    Supplied directory is not valid: diags/diag1/\n\n\n\nprint(\"openPMD version: \", series.openPMD)\n\nopenPMD version:  1.1.0\n\n\n\nlist(series.iterations)\ni = series.iterations[64]\n\n\n# record\nB = i.meshes[\"B\"]\nB.\n\nSyntaxError: invalid syntax (401656362.py, line 3)\n\n\n\n# record\nB = i.meshes[\"B\"]\n\n# record components\nB_x = B[\"x\"]\nB_y = B[\"y\"]\nB_z = B[\"z\"]\n\nB_x_data = B_x.load_chunk()\nB_y_data = B_y.load_chunk()\nB_z_data = B_z.load_chunk()\nseries.flush()\n\n\nplt.plot(B_x_data)\nplt.plot(B_y_data)\nplt.plot(B_z_data)\n\n[&lt;matplotlib.lines.Line2D at 0x2bdebd4d0&gt;]\n\n\n\n\n\n\n\n\n\n\nimport dill\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pywarpx import picmi\n\nconstants = picmi.constants\n\nmatplotlib.rcParams.update({\"font.size\": 20})\n\n# load simulation parameters\nwith open(\"sim_parameters.dpkl\", \"rb\") as f:\n    sim = dill.load(f)\n\n\nif sim.B_dir == 'z':\n    field_idx_dict = {'z': 4, 'Ez': 7, 'Bx': 8, 'By': 9}\n    data = np.loadtxt(\"diags/par_field_data.txt\", skiprows=1)\nelse:\n    if sim.dim == 1:\n        field_idx_dict = {'z': 4, 'Ez': 7, 'Bx': 8, 'By': 9}\n    else:\n        field_idx_dict = {'z': 2, 'Ez': 3, 'Bx': 4, 'By': 5}\n    data = np.loadtxt(\"diags/perp_field_data.txt\", skiprows=1)\n\n\n# step, t, z, Ez, Bx, By = raw_data.T\nstep = data[:,0]\n\nnum_steps = len(np.unique(step))\n\n# get the spatial resolution\nresolution = len(np.where(step == 0)[0]) - 1\n\n# reshape to separate spatial and time coordinates\nsim_data = data.reshape((num_steps, resolution+1, data.shape[1]))\n\n\nz_grid[:10]\n\narray([0.00000000e+00, 1.71636264e-06, 3.43272528e-06, 5.14908792e-06,\n       6.86545056e-06, 8.58181320e-06, 1.02981758e-05, 1.20145385e-05,\n       1.37309011e-05, 1.54472638e-05])\n\n\n\nz_grid = sim_data[1, :, field_idx_dict['z']]\nidx = np.argsort(z_grid)[1:]\ndz = np.mean(np.diff(z_grid[idx]))\ndt = np.mean(np.diff(sim_data[:,0,1]))\n\ndata = np.zeros((num_steps, resolution, 3))\nfor i in range(num_steps):\n    data[i,:,0] = sim_data[i,idx,field_idx_dict['Bx']]\n    data[i,:,1] = sim_data[i,idx,field_idx_dict['By']]\n    data[i,:,2] = sim_data[i,idx,field_idx_dict['Ez']]\n\nprint(f\"Data file contains {num_steps} time snapshots.\")\nprint(f\"Spatial resolution is {resolution}\")\n\nData file contains 1757 time snapshots.\nSpatial resolution is 1022\n\n\n\ndef get_analytic_R_mode(w):\n    return w / np.sqrt(1.0 + abs(w))\n\ndef get_analytic_L_mode(w):\n    return w / np.sqrt(1.0 - abs(w))\n\n\nif sim.B_dir == 'z':\n    global_norm = (\n        1.0 / (2.0*constants.mu0)\n        / ((3.0/2)*sim.n0*sim.T_plasma*constants.q_e)\n    )\nelse:\n    global_norm = (\n        constants.ep0 / 2.0\n        / ((3.0/2)*sim.n0*sim.T_plasma*constants.q_e)\n    )\n\nif sim.B_dir == 'z':\n    Bl = (data[:, :, 0] + 1.0j * data[:, :, 1]) / np.sqrt(2.0)\n    field_kw = np.fft.fftshift(np.fft.fft2(Bl))\nelse:\n    field_kw = np.fft.fftshift(np.fft.fft2(data[:, :, 2]))\n\nw_norm = sim.w_ci\nif sim.B_dir == 'z':\n    k_norm = 1.0 / sim.l_i\nelse:\n    k_norm = 1.0 / sim.rho_i\n\nk = 2*np.pi * np.fft.fftshift(np.fft.fftfreq(resolution, dz)) / k_norm\nw = 2*np.pi * np.fft.fftshift(np.fft.fftfreq(num_steps, dt)) / w_norm\nw = -np.flipud(w)\n\n# aspect = (xmax-xmin)/(ymax-ymin) / aspect_true\nextent = [k[0], k[-1], w[0], w[-1]]\n\nfig, ax1 = plt.subplots(1, 1, figsize=(10, 7.25))\n\nif sim.B_dir == 'z' and sim.dim == 1:\n    vmin = -3\n    vmax = 3.5\nelse:\n    vmin = None\n    vmax = None\n\nim = ax1.imshow(\n    np.log10(np.abs(field_kw**2) * global_norm), extent=extent,\n    aspect=\"equal\", cmap='inferno', vmin=vmin, vmax=vmax\n)\n\n# Colorbars\nfig.subplots_adjust(right=0.5)\ncbar_ax = fig.add_axes([0.525, 0.15, 0.03, 0.7])\nfig.colorbar(im, cax=cbar_ax, orientation='vertical')\n\n#cbar_lab = r'$\\log_{10}(\\frac{|B_{R/L}|^2}{2\\mu_0}\\frac{2}{3n_0k_BT_e})$'\nif sim.B_dir == 'z':\n    cbar_lab = r'$\\log_{10}(\\beta_{R/L})$'\nelse:\n    cbar_lab = r'$\\log_{10}(\\varepsilon_0|E_z|^2/(3n_0k_BT_e))$'\ncbar_ax.set_ylabel(cbar_lab, rotation=270, labelpad=30)\n\nif sim.B_dir == 'z':\n    # plot the L mode\n    ax1.plot(get_analytic_L_mode(w), np.abs(w), c='limegreen', ls='--', lw=1.25,\n            label='L mode:\\n'+r'$(kl_i)^2=\\frac{(\\omega/\\Omega_i)^2}{1-\\omega/\\Omega_i}$')\n    # plot the R mode\n    ax1.plot(get_analytic_R_mode(w), -np.abs(w), c='limegreen', ls='-.', lw=1.25,\n        label='R mode:\\n'+r'$(kl_i)^2=\\frac{(\\omega/\\Omega_i)^2}{1+\\omega/\\Omega_i}$')\n\n    ax1.plot(k,1.0+3.0*sim.v_ti/w_norm*k*k_norm, c='limegreen', ls=':', lw=1.25, label = r'$\\omega = \\Omega_i + 3v_{th,i} k$')\n    ax1.plot(k,1.0-3.0*sim.v_ti/w_norm*k*k_norm, c='limegreen', ls=':', lw=1.25)\n\nelse:\n    # digitized values from Munoz et al. (2018)\n    x = [0.006781609195402272, 0.1321379310344828, 0.2671034482758621, 0.3743678160919539, 0.49689655172413794, 0.6143908045977011, 0.766022988505747, 0.885448275862069, 1.0321149425287355, 1.193862068965517, 1.4417701149425288, 1.7736781609195402]\n    y = [-0.033194664836814436, 0.5306857657503109, 1.100227301968521, 1.5713856842646996, 2.135780760818287, 2.675601492473303, 3.3477291246729854, 3.8469357121413563, 4.4317021915340735, 5.1079898786293265, 6.10275764463696, 7.310074194793499]\n    ax1.plot(x, y, c='limegreen', ls='-.', lw=1.5, label=\"X mode\")\n\n    x = [3.9732873563218387, 3.6515862068965514, 3.306275862068966, 2.895655172413793, 2.4318850574712645, 2.0747586206896553, 1.8520229885057473, 1.6589195402298849, 1.4594942528735633, 1.2911724137931033, 1.1551264367816092, 1.0335402298850576, 0.8961149425287356, 0.7419770114942528, 0.6141379310344828, 0.4913103448275862]\n    y = [1.1145945018655916, 1.1193978642192393, 1.1391259596002916, 1.162971222713042, 1.1986533430544237, 1.230389844319595, 1.2649997855641806, 1.3265857528841618, 1.3706737573444268, 1.4368486511986962, 1.4933310460179268, 1.5485268259210019, 1.6386327572157655, 1.7062658146416778, 1.7828194021529358, 1.8533687867221342]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2, label=\"Bernstein modes\")\n\n    x = [3.9669885057471266, 3.6533333333333333, 3.3213563218390805, 2.9646896551724136, 2.6106436781609195, 2.2797011494252875, 1.910919540229885, 1.6811724137931034, 1.4499540229885057, 1.2577011494252872, 1.081057471264368, 0.8791494252873564, 0.7153103448275862]\n    y = [2.2274306300124374, 2.2428271218424327, 2.272505039241755, 2.3084873697302397, 2.3586224642964364, 2.402667581592829, 2.513873997512545, 2.5859673199811297, 2.6586610627439207, 2.7352146502551786, 2.8161427284813656, 2.887850066475104, 2.9455761890466183]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2)\n\n    x = [3.9764137931034487, 3.702022988505747, 3.459793103448276, 3.166712643678161, 2.8715862068965516, 2.5285057471264367, 2.2068505747126435, 1.9037011494252871, 1.6009885057471265, 1.3447816091954023, 1.1538850574712645, 0.9490114942528736]\n    y = [3.3231976669382854, 3.34875841660591, 3.378865205643951, 3.424454260839731, 3.474160483767209, 3.522194107303684, 3.6205343740618434, 3.7040356821203417, 3.785435519149119, 3.868851052879873, 3.9169704507440923, 3.952481022429987]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2)\n\n    x = [3.953609195402299, 3.7670114942528734, 3.5917471264367817, 3.39735632183908, 3.1724137931034484, 2.9408045977011494, 2.685977011494253, 2.4593563218390804, 2.2203218390804595, 2.0158850574712646, 1.834183908045977, 1.6522758620689655, 1.4937471264367814, 1.3427586206896551, 1.2075402298850575]\n    y = [4.427971008277223, 4.458335120298495, 4.481579963117039, 4.495861388686366, 4.544581206844791, 4.587425483552773, 4.638160998413175, 4.698631899472488, 4.757987734271133, 4.813955483123902, 4.862332203971352, 4.892481880173264, 4.9247759145687695, 4.947934983059571, 4.953124329888064]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2)\n\n# ax1.legend(loc='upper left')\nfig.legend(loc=7, fontsize=18)\n\nif sim.B_dir == 'z':\n    ax1.set_xlabel(r'$k l_i$')\n    ax1.set_title('$B_{R/L} = B_x \\pm iB_y$')\n    fig.suptitle(\"Parallel EM modes\")\n    ax1.set_xlim(-3, 3)\n    ax1.set_ylim(-6, 3)\n    dir_str = 'par'\nelse:\n    ax1.set_xlabel(r'$k \\rho_i$')\n    ax1.set_title('$E_z(k, \\omega)$')\n    fig.suptitle(f\"Perpendicular EM modes (ion Bernstein) - {sim.dim}D\")\n    ax1.set_xlim(-3, 3)\n    ax1.set_ylim(0, 8)\n    dir_str = 'perp'\n\nax1.set_ylabel(r'$\\omega / \\Omega_i$')\n\nplt.savefig(\n    f\"spectrum_{dir_str}_{sim.dim}d_{sim.substeps}_substeps_{sim.eta}_eta.png\",\n    bbox_inches='tight'\n)\nif not sim.test:\n    plt.show()\n\n/var/folders/tg/rfd0nr_970s3mv1fspgvkkxm0000gn/T/ipykernel_56467/195135233.py:5: RuntimeWarning: invalid value encountered in sqrt\n  return w / np.sqrt(1.0 - abs(w))\n\n\n\n\n\n\n\n\n\n\nidx\n\narray([1022,    1,    2, ..., 1019, 1020, 1021])\n\n\n\nplt.plot(idx, data[1200,:,1])\n\n\n\n\n\n\n\n\n\nif sim.test:\n    import os\n    import sys\n    import checksumAPI\n    \n    sys.path.insert(1, '../../../../warpx/Regression/Checksum/')\n\n    # this will be the name of the plot file\n    fn = sys.argv[1]\n    test_name = os.path.split(os.getcwd())[1]\n    checksumAPI.evaluate_checksum(test_name, fn)",
    "crumbs": [
      "Home",
      "Warpx",
      "Oblique Linear Alfven",
      "Analysis"
    ]
  },
  {
    "objectID": "warpx/oblique_linear_alfven/analysis.html#io",
    "href": "warpx/oblique_linear_alfven/analysis.html#io",
    "title": "Analysis",
    "section": "",
    "text": "import yt\n\n\nts = yt.load('./diags/diag???????')\n# ts = yt.load('./diags/diag???0032')\n\n\ndef plot(ds, normalize = True):\n    ad = ds.all_data()\n\n    x = ad[\"x\"]\n    \n    if normalize:\n        x = x / sim['d_i']\n    \n    ax = plt.subplot()\n    for field in [\"Bx\", \"By\", \"Bz\"]:\n        ax.plot(x, ad[field], label=field)\n        \ndef hodogram(ds, comp1=\"By\", comp2=\"Bz\"):\n    time = ds.current_time\n    time_norm = time.value / sim['t_ci']\n    ad = ds.all_data()\n    plt.plot(ad[comp1], ad[comp2], label=f\"t={time_norm:.2f}\")\n    plt.xlabel(comp1)\n    plt.ylabel(comp2)\n\n\ni=2\n# for ds in ts[i:i+1]:\nfor ds in ts[0:i]:\n    plot(ds)\n\nyt : [INFO     ] 2024-03-14 10:08:01,766 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-14 10:08:01,767 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:01,768 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:01,769 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:08:01,840 Parameters: current_time              = 0.035723867528782094\nyt : [INFO     ] 2024-03-14 10:08:01,841 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:01,842 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:01,842 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\ni=3\n# for ds in ts[i:i+1]:\nfor ds in ts[0:i]:\n    plot(ds)\n\nyt : [INFO     ] 2024-03-14 10:08:02,391 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-14 10:08:02,392 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:02,392 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:02,393 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:08:02,460 Parameters: current_time              = 0.035723867528782094\nyt : [INFO     ] 2024-03-14 10:08:02,461 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:02,461 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:02,461 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:08:02,525 Parameters: current_time              = 0.07144773505756419\nyt : [INFO     ] 2024-03-14 10:08:02,525 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:08:02,526 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:08:02,526 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\ni=4\n# for ds in ts[i:i+1]:\nfor ds in ts[0:i]:\n    plot(ds)\n\nyt : [INFO     ] 2024-03-14 10:07:58,686 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-14 10:07:58,686 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,687 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,688 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:07:58,759 Parameters: current_time              = 0.035723867528782094\nyt : [INFO     ] 2024-03-14 10:07:58,760 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,760 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,761 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:07:58,913 Parameters: current_time              = 0.07144773505756419\nyt : [INFO     ] 2024-03-14 10:07:58,913 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,913 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,914 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: current_time              = 0.10717160258634628\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-14 10:07:58,980 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\ni = 2\nds = ts[i]\nad = ds.all_data()\nad[\"B_x\"]\n\nyt : [INFO     ] 2024-03-13 19:52:44,658 Parameters: current_time              = 0.014289547011512778\nyt : [INFO     ] 2024-03-13 19:52:44,659 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:44,659 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:44,660 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\nunyt_array([nan, nan, nan, ..., nan, nan, nan], 'T')\n\n\n\nfor ds in ts:\n    hodogram(ds)\n    plt.legend()\n\nyt : [INFO     ] 2024-03-13 19:52:39,551 Parameters: current_time              = 0.0\nyt : [INFO     ] 2024-03-13 19:52:39,552 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:39,552 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:39,553 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-13 19:52:39,722 Parameters: current_time              = 0.007144773505756403\nyt : [INFO     ] 2024-03-13 19:52:39,723 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:39,723 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:39,724 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\nyt : [INFO     ] 2024-03-13 19:52:39,793 Parameters: current_time              = 0.014289547011512778\nyt : [INFO     ] 2024-03-13 19:52:39,794 Parameters: domain_dimensions         = [1024   32    1]\nyt : [INFO     ] 2024-03-13 19:52:39,794 Parameters: domain_left_edge          = [-340101.96874125       0.               0.        ]\nyt : [INFO     ] 2024-03-13 19:52:39,795 Parameters: domain_right_edge         = [3.40101969e+05 2.12563730e+04 1.00000000e+00]\n\n\n\n\n\n\n\n\n\n\nds.current_time\n\nunyt_quantity(1.31178042, 'code_time')\n\n\n\nds.field_list\n\n[('boxlib', 'Bx'),\n ('boxlib', 'By'),\n ('boxlib', 'Bz'),\n ('boxlib', 'Ex'),\n ('boxlib', 'Ey'),\n ('boxlib', 'Ez'),\n ('boxlib', 'jx'),\n ('boxlib', 'jy'),\n ('boxlib', 'jz')]\n\n\n\nyt.SlicePlot(ds, \"z\", (\"boxlib\", \"Bz\"))\n\nyt : [INFO     ] 2024-03-13 17:10:23,638 xlim = -728644.160452 728644.160452\nyt : [INFO     ] 2024-03-13 17:10:23,639 ylim = 0.000000 45540.260028\nyt : [INFO     ] 2024-03-13 17:10:23,640 xlim = -728644.160452 728644.160452\nyt : [INFO     ] 2024-03-13 17:10:23,641 ylim = 0.000000 45540.260028\nyt : [INFO     ] 2024-03-13 17:10:23,643 Making a fixed resolution buffer of (('boxlib', 'Bz')) 800 by 800\n\n\n\n\n\n\n\n\n\nimport openpmd_api as io\n\n# example: data handling\nimport numpy as np\n\n\nopenpmd_backend = \"h5\"\nseries = io.Series(f\"diags/diag1/openpmd_%06T.{openpmd_backend}\", io.Access.read_only)\n\nError: Read Error in frontend \nObject type:    File\nError type: Inaccessible\nFurther description:    Supplied directory is not valid: diags/diag1/\n\n\n\nprint(\"openPMD version: \", series.openPMD)\n\nopenPMD version:  1.1.0\n\n\n\nlist(series.iterations)\ni = series.iterations[64]\n\n\n# record\nB = i.meshes[\"B\"]\nB.\n\nSyntaxError: invalid syntax (401656362.py, line 3)\n\n\n\n# record\nB = i.meshes[\"B\"]\n\n# record components\nB_x = B[\"x\"]\nB_y = B[\"y\"]\nB_z = B[\"z\"]\n\nB_x_data = B_x.load_chunk()\nB_y_data = B_y.load_chunk()\nB_z_data = B_z.load_chunk()\nseries.flush()\n\n\nplt.plot(B_x_data)\nplt.plot(B_y_data)\nplt.plot(B_z_data)\n\n[&lt;matplotlib.lines.Line2D at 0x2bdebd4d0&gt;]\n\n\n\n\n\n\n\n\n\n\nimport dill\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pywarpx import picmi\n\nconstants = picmi.constants\n\nmatplotlib.rcParams.update({\"font.size\": 20})\n\n# load simulation parameters\nwith open(\"sim_parameters.dpkl\", \"rb\") as f:\n    sim = dill.load(f)\n\n\nif sim.B_dir == 'z':\n    field_idx_dict = {'z': 4, 'Ez': 7, 'Bx': 8, 'By': 9}\n    data = np.loadtxt(\"diags/par_field_data.txt\", skiprows=1)\nelse:\n    if sim.dim == 1:\n        field_idx_dict = {'z': 4, 'Ez': 7, 'Bx': 8, 'By': 9}\n    else:\n        field_idx_dict = {'z': 2, 'Ez': 3, 'Bx': 4, 'By': 5}\n    data = np.loadtxt(\"diags/perp_field_data.txt\", skiprows=1)\n\n\n# step, t, z, Ez, Bx, By = raw_data.T\nstep = data[:,0]\n\nnum_steps = len(np.unique(step))\n\n# get the spatial resolution\nresolution = len(np.where(step == 0)[0]) - 1\n\n# reshape to separate spatial and time coordinates\nsim_data = data.reshape((num_steps, resolution+1, data.shape[1]))\n\n\nz_grid[:10]\n\narray([0.00000000e+00, 1.71636264e-06, 3.43272528e-06, 5.14908792e-06,\n       6.86545056e-06, 8.58181320e-06, 1.02981758e-05, 1.20145385e-05,\n       1.37309011e-05, 1.54472638e-05])\n\n\n\nz_grid = sim_data[1, :, field_idx_dict['z']]\nidx = np.argsort(z_grid)[1:]\ndz = np.mean(np.diff(z_grid[idx]))\ndt = np.mean(np.diff(sim_data[:,0,1]))\n\ndata = np.zeros((num_steps, resolution, 3))\nfor i in range(num_steps):\n    data[i,:,0] = sim_data[i,idx,field_idx_dict['Bx']]\n    data[i,:,1] = sim_data[i,idx,field_idx_dict['By']]\n    data[i,:,2] = sim_data[i,idx,field_idx_dict['Ez']]\n\nprint(f\"Data file contains {num_steps} time snapshots.\")\nprint(f\"Spatial resolution is {resolution}\")\n\nData file contains 1757 time snapshots.\nSpatial resolution is 1022\n\n\n\ndef get_analytic_R_mode(w):\n    return w / np.sqrt(1.0 + abs(w))\n\ndef get_analytic_L_mode(w):\n    return w / np.sqrt(1.0 - abs(w))\n\n\nif sim.B_dir == 'z':\n    global_norm = (\n        1.0 / (2.0*constants.mu0)\n        / ((3.0/2)*sim.n0*sim.T_plasma*constants.q_e)\n    )\nelse:\n    global_norm = (\n        constants.ep0 / 2.0\n        / ((3.0/2)*sim.n0*sim.T_plasma*constants.q_e)\n    )\n\nif sim.B_dir == 'z':\n    Bl = (data[:, :, 0] + 1.0j * data[:, :, 1]) / np.sqrt(2.0)\n    field_kw = np.fft.fftshift(np.fft.fft2(Bl))\nelse:\n    field_kw = np.fft.fftshift(np.fft.fft2(data[:, :, 2]))\n\nw_norm = sim.w_ci\nif sim.B_dir == 'z':\n    k_norm = 1.0 / sim.l_i\nelse:\n    k_norm = 1.0 / sim.rho_i\n\nk = 2*np.pi * np.fft.fftshift(np.fft.fftfreq(resolution, dz)) / k_norm\nw = 2*np.pi * np.fft.fftshift(np.fft.fftfreq(num_steps, dt)) / w_norm\nw = -np.flipud(w)\n\n# aspect = (xmax-xmin)/(ymax-ymin) / aspect_true\nextent = [k[0], k[-1], w[0], w[-1]]\n\nfig, ax1 = plt.subplots(1, 1, figsize=(10, 7.25))\n\nif sim.B_dir == 'z' and sim.dim == 1:\n    vmin = -3\n    vmax = 3.5\nelse:\n    vmin = None\n    vmax = None\n\nim = ax1.imshow(\n    np.log10(np.abs(field_kw**2) * global_norm), extent=extent,\n    aspect=\"equal\", cmap='inferno', vmin=vmin, vmax=vmax\n)\n\n# Colorbars\nfig.subplots_adjust(right=0.5)\ncbar_ax = fig.add_axes([0.525, 0.15, 0.03, 0.7])\nfig.colorbar(im, cax=cbar_ax, orientation='vertical')\n\n#cbar_lab = r'$\\log_{10}(\\frac{|B_{R/L}|^2}{2\\mu_0}\\frac{2}{3n_0k_BT_e})$'\nif sim.B_dir == 'z':\n    cbar_lab = r'$\\log_{10}(\\beta_{R/L})$'\nelse:\n    cbar_lab = r'$\\log_{10}(\\varepsilon_0|E_z|^2/(3n_0k_BT_e))$'\ncbar_ax.set_ylabel(cbar_lab, rotation=270, labelpad=30)\n\nif sim.B_dir == 'z':\n    # plot the L mode\n    ax1.plot(get_analytic_L_mode(w), np.abs(w), c='limegreen', ls='--', lw=1.25,\n            label='L mode:\\n'+r'$(kl_i)^2=\\frac{(\\omega/\\Omega_i)^2}{1-\\omega/\\Omega_i}$')\n    # plot the R mode\n    ax1.plot(get_analytic_R_mode(w), -np.abs(w), c='limegreen', ls='-.', lw=1.25,\n        label='R mode:\\n'+r'$(kl_i)^2=\\frac{(\\omega/\\Omega_i)^2}{1+\\omega/\\Omega_i}$')\n\n    ax1.plot(k,1.0+3.0*sim.v_ti/w_norm*k*k_norm, c='limegreen', ls=':', lw=1.25, label = r'$\\omega = \\Omega_i + 3v_{th,i} k$')\n    ax1.plot(k,1.0-3.0*sim.v_ti/w_norm*k*k_norm, c='limegreen', ls=':', lw=1.25)\n\nelse:\n    # digitized values from Munoz et al. (2018)\n    x = [0.006781609195402272, 0.1321379310344828, 0.2671034482758621, 0.3743678160919539, 0.49689655172413794, 0.6143908045977011, 0.766022988505747, 0.885448275862069, 1.0321149425287355, 1.193862068965517, 1.4417701149425288, 1.7736781609195402]\n    y = [-0.033194664836814436, 0.5306857657503109, 1.100227301968521, 1.5713856842646996, 2.135780760818287, 2.675601492473303, 3.3477291246729854, 3.8469357121413563, 4.4317021915340735, 5.1079898786293265, 6.10275764463696, 7.310074194793499]\n    ax1.plot(x, y, c='limegreen', ls='-.', lw=1.5, label=\"X mode\")\n\n    x = [3.9732873563218387, 3.6515862068965514, 3.306275862068966, 2.895655172413793, 2.4318850574712645, 2.0747586206896553, 1.8520229885057473, 1.6589195402298849, 1.4594942528735633, 1.2911724137931033, 1.1551264367816092, 1.0335402298850576, 0.8961149425287356, 0.7419770114942528, 0.6141379310344828, 0.4913103448275862]\n    y = [1.1145945018655916, 1.1193978642192393, 1.1391259596002916, 1.162971222713042, 1.1986533430544237, 1.230389844319595, 1.2649997855641806, 1.3265857528841618, 1.3706737573444268, 1.4368486511986962, 1.4933310460179268, 1.5485268259210019, 1.6386327572157655, 1.7062658146416778, 1.7828194021529358, 1.8533687867221342]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2, label=\"Bernstein modes\")\n\n    x = [3.9669885057471266, 3.6533333333333333, 3.3213563218390805, 2.9646896551724136, 2.6106436781609195, 2.2797011494252875, 1.910919540229885, 1.6811724137931034, 1.4499540229885057, 1.2577011494252872, 1.081057471264368, 0.8791494252873564, 0.7153103448275862]\n    y = [2.2274306300124374, 2.2428271218424327, 2.272505039241755, 2.3084873697302397, 2.3586224642964364, 2.402667581592829, 2.513873997512545, 2.5859673199811297, 2.6586610627439207, 2.7352146502551786, 2.8161427284813656, 2.887850066475104, 2.9455761890466183]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2)\n\n    x = [3.9764137931034487, 3.702022988505747, 3.459793103448276, 3.166712643678161, 2.8715862068965516, 2.5285057471264367, 2.2068505747126435, 1.9037011494252871, 1.6009885057471265, 1.3447816091954023, 1.1538850574712645, 0.9490114942528736]\n    y = [3.3231976669382854, 3.34875841660591, 3.378865205643951, 3.424454260839731, 3.474160483767209, 3.522194107303684, 3.6205343740618434, 3.7040356821203417, 3.785435519149119, 3.868851052879873, 3.9169704507440923, 3.952481022429987]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2)\n\n    x = [3.953609195402299, 3.7670114942528734, 3.5917471264367817, 3.39735632183908, 3.1724137931034484, 2.9408045977011494, 2.685977011494253, 2.4593563218390804, 2.2203218390804595, 2.0158850574712646, 1.834183908045977, 1.6522758620689655, 1.4937471264367814, 1.3427586206896551, 1.2075402298850575]\n    y = [4.427971008277223, 4.458335120298495, 4.481579963117039, 4.495861388686366, 4.544581206844791, 4.587425483552773, 4.638160998413175, 4.698631899472488, 4.757987734271133, 4.813955483123902, 4.862332203971352, 4.892481880173264, 4.9247759145687695, 4.947934983059571, 4.953124329888064]\n    ax1.plot(x, y, c='limegreen', ls=':', lw=2)\n\n# ax1.legend(loc='upper left')\nfig.legend(loc=7, fontsize=18)\n\nif sim.B_dir == 'z':\n    ax1.set_xlabel(r'$k l_i$')\n    ax1.set_title('$B_{R/L} = B_x \\pm iB_y$')\n    fig.suptitle(\"Parallel EM modes\")\n    ax1.set_xlim(-3, 3)\n    ax1.set_ylim(-6, 3)\n    dir_str = 'par'\nelse:\n    ax1.set_xlabel(r'$k \\rho_i$')\n    ax1.set_title('$E_z(k, \\omega)$')\n    fig.suptitle(f\"Perpendicular EM modes (ion Bernstein) - {sim.dim}D\")\n    ax1.set_xlim(-3, 3)\n    ax1.set_ylim(0, 8)\n    dir_str = 'perp'\n\nax1.set_ylabel(r'$\\omega / \\Omega_i$')\n\nplt.savefig(\n    f\"spectrum_{dir_str}_{sim.dim}d_{sim.substeps}_substeps_{sim.eta}_eta.png\",\n    bbox_inches='tight'\n)\nif not sim.test:\n    plt.show()\n\n/var/folders/tg/rfd0nr_970s3mv1fspgvkkxm0000gn/T/ipykernel_56467/195135233.py:5: RuntimeWarning: invalid value encountered in sqrt\n  return w / np.sqrt(1.0 - abs(w))\n\n\n\n\n\n\n\n\n\n\nidx\n\narray([1022,    1,    2, ..., 1019, 1020, 1021])\n\n\n\nplt.plot(idx, data[1200,:,1])\n\n\n\n\n\n\n\n\n\nif sim.test:\n    import os\n    import sys\n    import checksumAPI\n    \n    sys.path.insert(1, '../../../../warpx/Regression/Checksum/')\n\n    # this will be the name of the plot file\n    fn = sys.argv[1]\n    test_name = os.path.split(os.getcwd())[1]\n    checksumAPI.evaluate_checksum(test_name, fn)",
    "crumbs": [
      "Home",
      "Warpx",
      "Oblique Linear Alfven",
      "Analysis"
    ]
  },
  {
    "objectID": "warpx/oblique_linear_alfven/inputs.html",
    "href": "warpx/oblique_linear_alfven/inputs.html",
    "title": "",
    "section": "",
    "text": "import numpy as np\nfrom pywarpx import picmi\n\n\nconstants = picmi.constants\n\n\nfrom utils import cosd, sind\nfrom space_analysis.simulation.warpx import HybridSimulation\n\nSupport gaussian_parse_momentum_function?\n\ndef init_field(\n    k,\n    B0,\n    A,  #: relative amplitude\n    theta=60,\n):\n    \"\"\"\n    Generate field with a wave propagating along the x axis at a large angle `theta` with respect to the background magnetic field lying in the x-z plane.\n\n    The initial waveis an Alfven mode in which the magnetic field fluctuation points along the y and z axis and has a relative amplitude $A = \\delta B_y / B_0$\n    \"\"\"\n\n    B0x = B0 * cosd(theta)\n    B0z = B0 * sind(theta)\n\n    # dB0z = B0 * A * np.cos(k * 0)\n\n    Bx_expression = f\"{B0x}\"\n    By_expression = f\"{A} * {B0} * cos({k} * x)\"\n    Bz_expression = f\"{B0z}\"\n\n    return picmi.AnalyticInitialField(\n        Bx_expression=Bx_expression,\n        By_expression=By_expression,\n        Bz_expression=Bz_expression,\n    )\n\n\ndef init_plasma(\n    vA,\n    n0,\n    v_ti,  #: ion thermal velocity\n    k,\n    B0,\n    A,  #: relative amplitude\n    theta=60,\n):\n    \"\"\"\n    The ion bulk and transverse velocity V remains parallel to the total transverse magnetic field.\n    \"\"\"\n    B0x = B0 * cosd(theta)\n    B0z = B0 * sind(theta)\n\n    px_expression = vA * B0x / B0\n    py_expression = f\"{vA * A} * cos({k} * x)\"\n    pz_expression = vA * B0z / B0\n    \n    px_expression = 0 \n    pz_expression = 0\n\n    momentum_expressions = [px_expression, py_expression, pz_expression]\n\n    return picmi.AnalyticDistribution(\n        density_expression=n0,\n        momentum_expressions=momentum_expressions,\n        # rms_velocity=[v_ti] * 3,\n    )\n\n\nclass AlfvenModes(HybridSimulation):\n    test: bool = True\n    # Applied field parameters\n    dim: int = 2\n    B0: float = 100 * 1e-9\n    \"\"\"Initial magnetic field strength (T)\"\"\"\n    n0: float = 100 * 1e6\n    \"\"\"Initial plasma density (m^-3)\"\"\"\n\n    vA_over_c: float = None\n    \"\"\"ratio of Alfven speed and the speed of light\"\"\"\n\n    A: float = 0.1  # relative amplitude\n\n    # Spatial domain\n    Lz_norm: float = 4\n    Lx_norm: float = 128  # spatial domain length in x direction (ion skin depths)\n\n    def model_post_init(self, __context):\n        \"\"\"Get input parameters for the specific case desired.\"\"\"\n        if self.test:\n            self.nppc = 64\n            self.m_ion_norm = 100\n\n        # calculate various plasma parameters based on the simulation input\n        self.get_plasma_quantities()\n\n        super().model_post_init(__context)\n\n        self.k = 1 * 2 * np.pi / self.Lx\n        self.setup_run()\n        self.dump()\n\n    def setup_field(self):\n        \"\"\"Setup external field\"\"\"\n\n        B_ext = init_field(k=self.k, B0=self.B0, A=self.A)\n        self._sim.add_applied_field(B_ext)\n        return self\n\n    def setup_particle(self):\n        \"\"\"setup the particle\"\"\"\n\n        dist = init_plasma(\n            vA=self.vA, n0=self.n0, v_ti=self.v_ti, k=self.k, B0=self.B0, A=self.A\n        )\n\n        ions = picmi.Species(\n            name=\"ions\",\n            charge_state=1,\n            mass=self.m_ion,\n            initial_distribution=dist,\n        )\n\n        self._sim.add_species(\n            ions,\n            layout=picmi.PseudoRandomLayout(\n                grid=self._grid, n_macroparticles_per_cell=self.nppc\n            ),\n        )\n        return self\n\n    def get_plasma_quantities(self):\n        \"\"\"Calculate various plasma parameters based on the simulation input.\"\"\"\n        # Ion mass (kg)\n        self.m_ion = self.m_ion_norm * constants.m_e\n\n        # Cyclotron angular frequency (rad/s) and period (s)\n        self.w_ci = constants.q_e * abs(self.B0) / self.m_ion\n        self.t_ci = 2.0 * np.pi / self.w_ci\n\n        # Alfven speed (m/s): vA = B / sqrt(mu0 * n * (M + m)) = c * omega_ci / w_pi\n        if self.n0 is not None:\n            self.vA = self.B0 / np.sqrt(\n                constants.mu0 * self.n0 * (self.m_ion + constants.m_e)\n            )\n        elif self.vA_over_c is not None:\n            self.vA = self.vA_over_c * constants.c\n            self.n0 = (self.B0 / self.vA) ** 2 / (\n                constants.mu0 * (self.m_ion + constants.m_e)\n            )\n\n        # Ion plasma frequency (rad/s)\n        self.w_pi = np.sqrt(constants.q_e**2 * self.n0 / (self.m_ion * constants.ep0))\n\n        # Skin depth (m): inertial length\n        self.d_i = constants.c / self.w_pi\n\n        # Ion thermal velocity (m/s) from beta = 2 * (v_ti / vA)**2\n        self.v_ti = np.sqrt(self.beta / 2.0) * self.vA\n\n        # Temperature (eV) from thermal speed: v_ti = sqrt(kT / M)\n        self.T_plasma = self.v_ti**2 * self.m_ion / constants.q_e  # eV\n        self.Te = self.T_plasma\n\n\nsimulation = AlfvenModes()\nsimulation._sim.write_input_file()\n\nNumerical parameters:\n    dt = 5.6e-04 s\n    total steps = 6400\n\nInitializing simulation with input parameters:\n    Te = 24.588 eV\n    n = 1.0e+02 cm^-3\n    B0 = 100.00 nT\n    M/m = 100\n\nPlasma parameters:\n    d_i = 5.3e+03 m\n    t_ci = 3.6e-02 s\n    v_ti = 2.1e+05 m/s\n    vA = 9.3e+05 m/s\n    vA/c = 0.0031021956193735692\n\n\n\n\nsimulation._sim.step()\n\n\nsimulation.diag_steps\n\nprint(f\"\"\"\n    {simulation._sim.max_steps}\n    {simulation._sim.time_step_size}\n    \"\"\"\n)\n\n\n    6400\n    0.0005581854301372202\n    \n\n\n\n# simulation._sim.step()",
    "crumbs": [
      "Home",
      "Warpx",
      "Oblique Linear Alfven",
      "Inputs"
    ]
  },
  {
    "objectID": "warpx/EMModes/inputs.html",
    "href": "warpx/EMModes/inputs.html",
    "title": "",
    "section": "",
    "text": "import numpy as np\nfrom pywarpx import picmi\nfrom space_analysis.simulation.warpx import HybridSimulation\n\nconstants = picmi.constants\n\n\nclass EMModes(HybridSimulation):\n    \"\"\"The following runs a simulation of an uniform plasma at a set\n    temperature (Te = Ti) with an external magnetic field applied in either the\n    z-direction (parallel to domain) or x-direction (perpendicular to domain).\n    The analysis script (in this same directory) analyzes the output field data\n    for EM modes. This input is based on the EM modes tests as described by\n    Munoz et al. (2018) and tests done by Scott Nicks at TAE Technologies.\n    \"\"\"\n\n    # Applied field parameters\n    dim: int = 2\n    B_dir: str = \"z\"  # Direction of the initial magnetic field\n    B0: float = 0.25  # Initial magnetic field strength (T)\n    betas: list[float] = [0.01, 0.1]  # Plasma beta, used to calculate temperature\n\n    # Plasma species parameters\n    m_ion_norms: list[float] = [100.0, 400.0]  # Ion mass (electron masses)\n    vA_over_cs: list[float] = [\n        1e-4,\n        1e-3,\n    ]  # ratio of Alfven speed and the speed of light\n\n    # Spatial domain\n    nz: int = 1024  # number of cells in z direction\n    nx: int = 8  # number of cells in x (and y) direction for &gt;1 dimensions\n\n    # Temporal domain (if not run as a CI test)\n    time_norm: float = 300.0  # Simulation temporal length (ion cyclotron periods)\n\n    # Numerical parameters\n    nppc: int = 256  # Seed number of particles per cell\n    dz_norm: float = 1.0 / 10.0  # Cell size (ion skin depths)\n    dt_norms: list[float] = [5e-3, 4e-3]  # Time step (ion cyclotron periods)\n\n    # Plasma resistivity - used to dampen the mode excitation\n    eta: float = 1e-7\n    # Number of substeps used to update B\n    substeps: int = 20\n\n    def model_post_init(self, __context):\n        \"\"\"Get input parameters for the specific case desired.\"\"\"\n\n        # get simulation parameters from the defaults given the direction of\n        # the initial B-field and the dimensionality\n        self.get_simulation_parameters()\n\n        # calculate various plasma parameters based on the simulation input\n        self.get_plasma_quantities()\n\n        # output diagnostics 20 times per cyclotron period\n        self.diag_steps = int(1.0 / 20 / self.dt_norm)\n\n        super().model_post_init(__context)\n\n        self.setup_run()\n\n    def get_simulation_parameters(self):\n        \"\"\"Pick appropriate parameters from the defaults given the direction\n        of the B-field and the simulation dimensionality.\"\"\"\n        if self.B_dir == \"z\":\n            idx = 0\n            self.Bx = 0.0\n            self.By = 0.0\n            self.Bz = self.B0\n        elif self.B_dir == \"y\":\n            idx = 1\n            self.Bx = 0.0\n            self.By = self.B0\n            self.Bz = 0.0\n        else:\n            idx = 1\n            self.Bx = self.B0\n            self.By = 0.0\n            self.Bz = 0.0\n\n        self.m_ion_norm = self.m_ion_norms[idx]\n        self.beta = self.betas[idx]\n        self.vA_over_c = self.vA_over_cs[idx]\n        self.dt_norm = self.dt_norms[idx]\n\n    def get_plasma_quantities(self):\n        \"\"\"Calculate various plasma parameters based on the simulation input.\"\"\"\n        # Ion mass (kg)\n        self.m_ion = self.m_ion_norm * constants.m_e\n\n        # Cyclotron angular frequency (rad/s) and period (s)\n        self.w_ci = constants.q_e * abs(self.B0) / self.m_ion\n        self.t_ci = 2.0 * np.pi / self.w_ci\n\n        # Alfven speed (m/s): vA = B / sqrt(mu0 * n * (M + m)) = c * omega_ci / w_pi\n        self.vA = self.vA_over_c * constants.c\n        self.n_plasma = (self.B0 / self.vA) ** 2 / (\n            constants.mu0 * (self.m_ion + constants.m_e)\n        )\n\n        # Ion plasma frequency (Hz)\n        self.w_pi = np.sqrt(\n            constants.q_e**2 * self.n_plasma / (self.m_ion * constants.ep0)\n        )\n\n        # Skin depth (m)\n        self.d_i = constants.c / self.w_pi\n\n        # Ion thermal velocity (m/s) from beta = 2 * (v_ti / vA)**2\n        self.v_ti = np.sqrt(self.beta / 2.0) * self.vA\n\n        # Temperature (eV) from thermal speed: v_ti = sqrt(kT / M)\n        self.T_plasma = self.v_ti**2 * self.m_ion / constants.q_e  # eV\n\n        self.n0 = self.n_plasma\n        self.Te = self.T_plasma\n\n    def setup_field(self):\n        \"\"\"Setup external field\"\"\"\n        B_ext = picmi.AnalyticInitialField(\n            Bx_expression=self.Bx, By_expression=self.By, Bz_expression=self.Bz\n        )\n        self._sim.add_applied_field(B_ext)\n\n    def setup_particle(self):\n        self.ions = picmi.Species(\n            name=\"ions\",\n            charge=\"q_e\",\n            mass=self.m_ion,\n            initial_distribution=picmi.UniformDistribution(\n                density=self.n_plasma,\n                rms_velocity=[self.v_ti] * 3,\n            ),\n        )\n        self._sim.add_species(\n            self.ions,\n            layout=picmi.PseudoRandomLayout(\n                grid=self._grid, n_macroparticles_per_cell=self.nppc\n            ),\n        )\n        return self\n\n    def setup_run(self):\n        \"\"\"Setup simulation components.\"\"\"\n        super().setup_run()\n\n        #######################################################################\n        # Initialize self._sim                                               #\n        #######################################################################\n        self._sim.write_input_file(\"inputs_em_modes\")\n\n\nsim = EMModes()\n\nNumerical parameters:\n    dt = 7.1e-11 s\n    total steps = 60000\n\nInitializing simulation with input parameters:\n    Te = 0.003 eV\n    n = 6.0e+17 cm^-3\n    B0 = 250000000.00 nT\n    M/m = 100\n\nPlasma parameters:\n    d_i = 6.9e-05 m\n    t_ci = 1.4e-08 s\n    v_ti = 2.1e+03 m/s\n    vA = 3.0e+04 m/s\n    vA/c = 0.0001\n\n\n\n\nsim._sim.step()\n\n&lt;pywarpx.picmi.Cartesian2DGrid at 0x10a51df50&gt;",
    "crumbs": [
      "Home",
      "Warpx",
      "EMModes",
      "Inputs"
    ]
  }
]